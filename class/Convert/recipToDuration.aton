@@BEGIN:	FunctionDocumentation
@INDEXED:	yes
@CLASSNAME:	Convert
@METHOD:	recipToDuration
@ACCESS:	public
@RETURN:	static HumNum  
@PARAMETERS:	const string& recip, HumNum scale = 4, string separator = " "
@FILE:		Convert-rhythm.cpp
@LINES:		21-121
@SEEALSO:
@SHORTDESC:	Convert **recip rhythmic values into rational number durations in terms of quarter notes.
@LONGDESC:	Convert **recip rhythmic values into
	rational number durations in terms of quarter notes.  For example "4"
	will be converted to 1, "4." to 3/2 (1+1/2).  The second parameter
	is a scaling factor which can change the rhythmic value's base duration.
	Giving a scale of 1 will return the duration in whole note units, so
	"4" will return a value of 1/4 (one quarter of a whole note).  Using
	3/2 will give the duration in terms of dotted-quarter note units.
	The third parameter is the sub-token separate.  For example if the input
	string contains a space, anything after the first space will be ignored
	when extracting the string.  **kern data which also includes the pitch
	along with the rhythm can also be given and will be ignored.
	default value: scale = 4 (duration in terms of quarter notes)
	default value: separator = " " (sub-token separator)
	

@@BEGIN: EXAMPLE
@DESCRIPTION:
@CODE:
@OUTPUT:
@@END:	EXAMPLE

@SRCCODE:
//////////////////////////////
//
// Convert::recipToDuration -- Convert **recip rhythmic values into
//     rational number durations in terms of quarter notes.  For example "4"
//     will be converted to 1, "4." to 3/2 (1+1/2).  The second parameter
//     is a scaling factor which can change the rhythmic value's base duration.
//     Giving a scale of 1 will return the duration in whole note units, so
//     "4" will return a value of 1/4 (one quarter of a whole note).  Using
//     3/2 will give the duration in terms of dotted-quarter note units.
//     The third parameter is the sub-token separate.  For example if the input
//     string contains a space, anything after the first space will be ignored
//     when extracting the string.  **kern data which also includes the pitch
//     along with the rhythm can also be given and will be ignored.
//        default value: scale = 4 (duration in terms of quarter notes)
//        default value: separator = " " (sub-token separator)
//

HumNum Convert::recipToDuration(const string& recip, HumNum scale,
		string separator) {
	size_t loc;
	loc = recip.find(separator);
	string subtok;
	if (loc != string::npos) {
		subtok = recip.substr(0, loc);
	} else {
		subtok = recip;
	}

	loc = recip.find('q');
	if (loc != string::npos) {
		// grace note, ignore printed rhythm
		HumNum zero(0);
		return zero;
	}

	int dotcount = 0;
	int i;
	int numi = -1;
	for (i=0; i<subtok.size(); i++) {
		if (subtok[i] == '.') {
			dotcount++;
		}
		if ((numi < 0) && isdigit(subtok[i])) {
			numi = i;
		}
	}
	loc = subtok.find("%");
	int numerator = 1;
	int denominator = 1;
	HumNum output;
	if (loc != string::npos) {
		// reciprocal rhythm
		numerator = 1;
		denominator = subtok[numi++] - '0';
		while ((numi < subtok.size()) && isdigit(subtok[numi])) {
			denominator = denominator * 10 + (subtok[numi++] - '0');
		}
		if ((loc + 1 < subtok.size()) && isdigit(subtok[loc+1])) {
			int xi = loc + 1;
			numerator = subtok[xi++] - '0';
			while ((xi < subtok.size()) && isdigit(subtok[xi])) {
				numerator = numerator * 10 + (subtok[xi++] - '0');
			}
		}
		output.setValue(numerator, denominator);
	} else if (numi < 0) {
		// no rhythm found
		HumNum zero(0);
		return zero;
	} else if (subtok[numi] == '0') {
		// 0-symbol
		int zerocount = 1;
		for (i=numi+1; i<subtok.size(); i++) {
			if (subtok[i] == '0') {
				zerocount++;
			} else {
				break;
			}
		}
		numerator = (int)pow(2, zerocount);
		output.setValue(numerator, 1);
	} else {
		// plain rhythm
		denominator = subtok[numi++] - '0';
		while ((numi < subtok.size()) && isdigit(subtok[numi])) {
			denominator = denominator * 10 + (subtok[numi++] - '0');
		}
		output.setValue(1, denominator);
	}

	if (dotcount <= 0) {
		return output * scale;
	}

	int bot = (int)pow(2.0, dotcount);
	int top = (int)pow(2.0, dotcount + 1) - 1;
	HumNum factor(top, bot);
	return output * factor * scale;
}




@@END:	FunctionDocumentation

