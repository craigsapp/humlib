@@BEGIN:	FunctionDocumentation
@INDEXED:	yes
@CLASSNAME:	HumHash
@METHOD:	printXml
@ACCESS:	public
@RETURN:	ostream&       
@PARAMETERS:	ostream& out = cout, int level = 0, const string& indent = "\t"
@FILE:		HumHash.cpp
@LINES:		1012-1074
@SHORTDESC:	Print object as a <parameters> element for in a HumdrumXML file.
@LONGDESC:	Print object as a <parameters> element for
	in a HumdrumXML file.
	

@@BEGIN: EXAMPLE
@DESCRIPTION:
@CODE:
@OUTPUT:
@@END:	EXAMPLE

@SRCCODE:

ostream& HumHash::printXml(ostream& out, int level, const string& indent) {
	if (parameters == NULL) {
		return out;
	}
	if (parameters->size() == 0) {
		return out;
	}
	
	stringstream str;
	bool found = 0;

	HumdrumToken* ref = NULL;
	level++;
	for (auto& it1 : *(parameters)) {
		if (it1.second.size() == 0) {
			continue;
		}
		if (!found) {
			found = 1;
		}
		str << Convert::repeatString(indent, level++);
		str << "<namespace n=\"1\" name=\"" << it1.first << "\">\n";
		for (auto& it2 : it1.second) {
			if (it2.second.size() == 0) {
				continue;
			}

			str << Convert::repeatString(indent, level++);
			str << "<namespace n=\"2\" name=\"" << it2.first << "\">\n";

			for (auto& it3 : it2.second) {
				str << Convert::repeatString(indent, level);
				str << "<parameter key=\"" << it3.first << "\"";
				str << " value=\"";
				str << Convert::encodeXml(it3.second) << "\"";
				str << " idref=\"";
				ref = it3.second.origin;
				if (ref != NULL) {
					str << ref->getXmlId();
				}
				str << "\"";
				str << "/>\n";
			}
			str << Convert::repeatString(indent, --level) << "</namespace>\n";
		}
		str << Convert::repeatString(indent, --level) << "</namespace>\n";
	}
	if (found) {
		str << Convert::repeatString(indent, --level) << "</parameters>\n";
		out << Convert::repeatString(indent, level) << "<parameters>\n";
		out << str.str();
	}

	return out;
}


@@END:	FunctionDocumentation

