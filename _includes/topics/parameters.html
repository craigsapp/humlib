

minHumdrum can processes non-data parameters embedded in local or global
comments before the data token, interpretation or barline in a spine.
The form of a parameter is:


```
![!][ns1]:[ns2]:key1=value1[:key2=value[:key3=value3]
```

The parameter system includes two optional namespace prefixes
to the list of parameters.  A parameter in the default namespace
will start with two colons (:), followed by the parameter list. For
example here is a parameter list which does not include any namespace
qualifiers:

```
!::A=a:B=b
``` 

With one namespace qualifier, the form would look like this:

```
!:C:A=a:B=b
```

And with a full name space description:

```
!:D:C:A=a:B=b
```

Namespaces and keys may not contain spaces or colons, and ideally should 
only contain letters, digits, dashes (-), and underscores (_).  Values
may contain any character except for colons or newlines.  To represent
a colon, use `&colon;` in place of `:`.

When the minHumdurm parser reads a Humdrum file with parameters, it will 
automatically parse the parameters and attaches them to the next non-null
token in the spine which follows.  These parameters can then be accessed
from a HumdrumToken with the functions:

* <span class="mhcf paren">HumHash::getValue</span> which returns the string for the parameter, 
* <span class="mhcf paren">HumHash::getValueInt</span> for parsing it as an integer, 
* <span class="mhcf paren">HumHash::getValueBool</span> for a boolean, 
* <span class="mhcf paren">HumHash::getValueFloat</span> for a double, or 
* <span class="mhcf paren">HumHash::getValueFraction</span> as a HumHash fraction.

Here is an example Humdrum file which adds the parameter key/value
"Z=z" for a data token:

```
**A
a1
!::Z=z
a2
a3
*-
```

The following code would print the value of the Z parameter ("z"):

```
HumdrumFile infile;
cout << infile.token(3,0).getValue("Z");
```

The list of parameters for a token are exposed when generating a 
HumdruXML file for the data.  will be given as a child of the 
&lt;field&gt; element that represents the data token.  Here is 
the field element for the "a2" in XML format:

```
<field n="0" track="1" token="a2" xml:id="loc3_0">
   <dataType>A</dataType>
   <tokenType>data</tokenType>
   <duration float="0"/>
   <parameters>
      <namespace n="1" name="">
         <namespace n="2" name="">
            <parameter key="Z" value="z" idref="loc2_0"/>
         </namespace>
      </namespace>
   </parameters>
</field>
```

The parameter@idref attribute is an XML id which points to the source line 
used to set the parameter.

Parameters may be split into separate comments.  These two forms are 
equivalent:

```
**A
a1
!::Z=z:Y=y
a2
a3
*-
```

```
**A
a1
!::Z=z
!::Y=y
a2
a3
*-
```

This will cause token `a2` to have two parameters `Z=z` and `Y=y`.


When the same key is used to set the parameter for a token, only the
first value of the parameter will be used.  In the following example,
`.getValue("Z")` will return `z1`:

```
**A
a1
!::Z=z1
!::Z=z2
a2
a3
*-
```


Example with namespaces:

```
**A
a1
!ns1:ns2:Z=z1
a2
a3
*-
```

To access the parameter for `a2`, the following two cases are equivalent:

```
infile.token(3, 0).getValue("ns1:ns2:Z");
infile.token(3, 0).getValue("ns1", "ns2", Z");
```





